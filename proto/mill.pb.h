// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mill.proto

#ifndef PROTOBUF_mill_2eproto__INCLUDED
#define PROTOBUF_mill_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace mill {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_mill_2eproto();
void protobuf_AssignDesc_mill_2eproto();
void protobuf_ShutdownFile_mill_2eproto();

class Command;
class CommandList;
class CommandReceived;
class CommandComplete;
class MillState;
class MillState_Axis;
class Request;
class Response;

enum Command_CommandType {
  Command_CommandType_PAUSE = 0,
  Command_CommandType_FEED = 1,
  Command_CommandType_FEEDTO = 2,
  Command_CommandType_RAPID = 3,
  Command_CommandType_RAPIDTO = 4,
  Command_CommandType_ARCTO = 5,
  Command_CommandType_ZERO = 6
};
bool Command_CommandType_IsValid(int value);
const Command_CommandType Command_CommandType_CommandType_MIN = Command_CommandType_PAUSE;
const Command_CommandType Command_CommandType_CommandType_MAX = Command_CommandType_ZERO;
const int Command_CommandType_CommandType_ARRAYSIZE = Command_CommandType_CommandType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Command_CommandType_descriptor();
inline const ::std::string& Command_CommandType_Name(Command_CommandType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Command_CommandType_descriptor(), value);
}
inline bool Command_CommandType_Parse(
    const ::std::string& name, Command_CommandType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Command_CommandType>(
    Command_CommandType_descriptor(), name, value);
}
enum MillState_Axis_Direction {
  MillState_Axis_Direction_IDLE = 0,
  MillState_Axis_Direction_POS = 1,
  MillState_Axis_Direction_NEG = 1
};
bool MillState_Axis_Direction_IsValid(int value);
const MillState_Axis_Direction MillState_Axis_Direction_Direction_MIN = MillState_Axis_Direction_IDLE;
const MillState_Axis_Direction MillState_Axis_Direction_Direction_MAX = MillState_Axis_Direction_POS;
const int MillState_Axis_Direction_Direction_ARRAYSIZE = MillState_Axis_Direction_Direction_MAX + 1;

const ::google::protobuf::EnumDescriptor* MillState_Axis_Direction_descriptor();
inline const ::std::string& MillState_Axis_Direction_Name(MillState_Axis_Direction value) {
  return ::google::protobuf::internal::NameOfEnum(
    MillState_Axis_Direction_descriptor(), value);
}
inline bool MillState_Axis_Direction_Parse(
    const ::std::string& name, MillState_Axis_Direction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MillState_Axis_Direction>(
    MillState_Axis_Direction_descriptor(), name, value);
}
// ===================================================================

class Command : public ::google::protobuf::Message {
 public:
  Command();
  virtual ~Command();
  
  Command(const Command& from);
  
  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Command& default_instance();
  
  void Swap(Command* other);
  
  // implements Message ----------------------------------------------
  
  Command* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Command& from);
  void MergeFrom(const Command& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Command_CommandType CommandType;
  static const CommandType PAUSE = Command_CommandType_PAUSE;
  static const CommandType FEED = Command_CommandType_FEED;
  static const CommandType FEEDTO = Command_CommandType_FEEDTO;
  static const CommandType RAPID = Command_CommandType_RAPID;
  static const CommandType RAPIDTO = Command_CommandType_RAPIDTO;
  static const CommandType ARCTO = Command_CommandType_ARCTO;
  static const CommandType ZERO = Command_CommandType_ZERO;
  static inline bool CommandType_IsValid(int value) {
    return Command_CommandType_IsValid(value);
  }
  static const CommandType CommandType_MIN =
    Command_CommandType_CommandType_MIN;
  static const CommandType CommandType_MAX =
    Command_CommandType_CommandType_MAX;
  static const int CommandType_ARRAYSIZE =
    Command_CommandType_CommandType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CommandType_descriptor() {
    return Command_CommandType_descriptor();
  }
  static inline const ::std::string& CommandType_Name(CommandType value) {
    return Command_CommandType_Name(value);
  }
  static inline bool CommandType_Parse(const ::std::string& name,
      CommandType* value) {
    return Command_CommandType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional .mill.Command.CommandType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::mill::Command_CommandType type() const;
  inline void set_type(::mill::Command_CommandType value);
  
  // optional double x = 2;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 2;
  inline double x() const;
  inline void set_x(double value);
  
  // optional double y = 3;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 3;
  inline double y() const;
  inline void set_y(double value);
  
  // optional double z = 4;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 4;
  inline double z() const;
  inline void set_z(double value);
  
  // optional double v = 5;
  inline bool has_v() const;
  inline void clear_v();
  static const int kVFieldNumber = 5;
  inline double v() const;
  inline void set_v(double value);
  
  // optional double a = 6;
  inline bool has_a() const;
  inline void clear_a();
  static const int kAFieldNumber = 6;
  inline double a() const;
  inline void set_a(double value);
  
  // optional double i = 7;
  inline bool has_i() const;
  inline void clear_i();
  static const int kIFieldNumber = 7;
  inline double i() const;
  inline void set_i(double value);
  
  // optional double j = 8;
  inline bool has_j() const;
  inline void clear_j();
  static const int kJFieldNumber = 8;
  inline double j() const;
  inline void set_j(double value);
  
  // optional double k = 9;
  inline bool has_k() const;
  inline void clear_k();
  static const int kKFieldNumber = 9;
  inline double k() const;
  inline void set_k(double value);
  
  // @@protoc_insertion_point(class_scope:mill.Command)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();
  inline void set_has_v();
  inline void clear_has_v();
  inline void set_has_a();
  inline void clear_has_a();
  inline void set_has_i();
  inline void clear_has_i();
  inline void set_has_j();
  inline void clear_has_j();
  inline void set_has_k();
  inline void clear_has_k();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  double x_;
  double y_;
  double z_;
  double v_;
  double a_;
  double i_;
  double j_;
  double k_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_mill_2eproto();
  friend void protobuf_AssignDesc_mill_2eproto();
  friend void protobuf_ShutdownFile_mill_2eproto();
  
  void InitAsDefaultInstance();
  static Command* default_instance_;
};
// -------------------------------------------------------------------

class CommandList : public ::google::protobuf::Message {
 public:
  CommandList();
  virtual ~CommandList();
  
  CommandList(const CommandList& from);
  
  inline CommandList& operator=(const CommandList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandList& default_instance();
  
  void Swap(CommandList* other);
  
  // implements Message ----------------------------------------------
  
  CommandList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandList& from);
  void MergeFrom(const CommandList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .mill.Command command = 1;
  inline int command_size() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 1;
  inline const ::mill::Command& command(int index) const;
  inline ::mill::Command* mutable_command(int index);
  inline ::mill::Command* add_command();
  inline const ::google::protobuf::RepeatedPtrField< ::mill::Command >&
      command() const;
  inline ::google::protobuf::RepeatedPtrField< ::mill::Command >*
      mutable_command();
  
  // @@protoc_insertion_point(class_scope:mill.CommandList)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::mill::Command > command_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_mill_2eproto();
  friend void protobuf_AssignDesc_mill_2eproto();
  friend void protobuf_ShutdownFile_mill_2eproto();
  
  void InitAsDefaultInstance();
  static CommandList* default_instance_;
};
// -------------------------------------------------------------------

class CommandReceived : public ::google::protobuf::Message {
 public:
  CommandReceived();
  virtual ~CommandReceived();
  
  CommandReceived(const CommandReceived& from);
  
  inline CommandReceived& operator=(const CommandReceived& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandReceived& default_instance();
  
  void Swap(CommandReceived* other);
  
  // implements Message ----------------------------------------------
  
  CommandReceived* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandReceived& from);
  void MergeFrom(const CommandReceived& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 number = 1;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 1;
  inline ::google::protobuf::int32 number() const;
  inline void set_number(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:mill.CommandReceived)
 private:
  inline void set_has_number();
  inline void clear_has_number();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 number_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_mill_2eproto();
  friend void protobuf_AssignDesc_mill_2eproto();
  friend void protobuf_ShutdownFile_mill_2eproto();
  
  void InitAsDefaultInstance();
  static CommandReceived* default_instance_;
};
// -------------------------------------------------------------------

class CommandComplete : public ::google::protobuf::Message {
 public:
  CommandComplete();
  virtual ~CommandComplete();
  
  CommandComplete(const CommandComplete& from);
  
  inline CommandComplete& operator=(const CommandComplete& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandComplete& default_instance();
  
  void Swap(CommandComplete* other);
  
  // implements Message ----------------------------------------------
  
  CommandComplete* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandComplete& from);
  void MergeFrom(const CommandComplete& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 number = 1;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 1;
  inline ::google::protobuf::int32 number() const;
  inline void set_number(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:mill.CommandComplete)
 private:
  inline void set_has_number();
  inline void clear_has_number();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 number_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_mill_2eproto();
  friend void protobuf_AssignDesc_mill_2eproto();
  friend void protobuf_ShutdownFile_mill_2eproto();
  
  void InitAsDefaultInstance();
  static CommandComplete* default_instance_;
};
// -------------------------------------------------------------------

class MillState_Axis : public ::google::protobuf::Message {
 public:
  MillState_Axis();
  virtual ~MillState_Axis();
  
  MillState_Axis(const MillState_Axis& from);
  
  inline MillState_Axis& operator=(const MillState_Axis& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MillState_Axis& default_instance();
  
  void Swap(MillState_Axis* other);
  
  // implements Message ----------------------------------------------
  
  MillState_Axis* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MillState_Axis& from);
  void MergeFrom(const MillState_Axis& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef MillState_Axis_Direction Direction;
  static const Direction IDLE = MillState_Axis_Direction_IDLE;
  static const Direction POS = MillState_Axis_Direction_POS;
  static const Direction NEG = MillState_Axis_Direction_NEG;
  static inline bool Direction_IsValid(int value) {
    return MillState_Axis_Direction_IsValid(value);
  }
  static const Direction Direction_MIN =
    MillState_Axis_Direction_Direction_MIN;
  static const Direction Direction_MAX =
    MillState_Axis_Direction_Direction_MAX;
  static const int Direction_ARRAYSIZE =
    MillState_Axis_Direction_Direction_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Direction_descriptor() {
    return MillState_Axis_Direction_descriptor();
  }
  static inline const ::std::string& Direction_Name(Direction value) {
    return MillState_Axis_Direction_Name(value);
  }
  static inline bool Direction_Parse(const ::std::string& name,
      Direction* value) {
    return MillState_Axis_Direction_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional .mill.MillState.Axis.Direction direction = 1;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 1;
  inline ::mill::MillState_Axis_Direction direction() const;
  inline void set_direction(::mill::MillState_Axis_Direction value);
  
  // optional double position = 2;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 2;
  inline double position() const;
  inline void set_position(double value);
  
  // optional double velocity = 3;
  inline bool has_velocity() const;
  inline void clear_velocity();
  static const int kVelocityFieldNumber = 3;
  inline double velocity() const;
  inline void set_velocity(double value);
  
  // optional double acceleration = 4;
  inline bool has_acceleration() const;
  inline void clear_acceleration();
  static const int kAccelerationFieldNumber = 4;
  inline double acceleration() const;
  inline void set_acceleration(double value);
  
  // @@protoc_insertion_point(class_scope:mill.MillState.Axis)
 private:
  inline void set_has_direction();
  inline void clear_has_direction();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_velocity();
  inline void clear_has_velocity();
  inline void set_has_acceleration();
  inline void clear_has_acceleration();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  double position_;
  double velocity_;
  double acceleration_;
  int direction_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_mill_2eproto();
  friend void protobuf_AssignDesc_mill_2eproto();
  friend void protobuf_ShutdownFile_mill_2eproto();
  
  void InitAsDefaultInstance();
  static MillState_Axis* default_instance_;
};
// -------------------------------------------------------------------

class MillState : public ::google::protobuf::Message {
 public:
  MillState();
  virtual ~MillState();
  
  MillState(const MillState& from);
  
  inline MillState& operator=(const MillState& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MillState& default_instance();
  
  void Swap(MillState* other);
  
  // implements Message ----------------------------------------------
  
  MillState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MillState& from);
  void MergeFrom(const MillState& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef MillState_Axis Axis;
  
  // accessors -------------------------------------------------------
  
  // optional .mill.MillState.Axis x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline const ::mill::MillState_Axis& x() const;
  inline ::mill::MillState_Axis* mutable_x();
  inline ::mill::MillState_Axis* release_x();
  
  // optional .mill.MillState.Axis y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline const ::mill::MillState_Axis& y() const;
  inline ::mill::MillState_Axis* mutable_y();
  inline ::mill::MillState_Axis* release_y();
  
  // optional .mill.MillState.Axis z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline const ::mill::MillState_Axis& z() const;
  inline ::mill::MillState_Axis* mutable_z();
  inline ::mill::MillState_Axis* release_z();
  
  // optional .mill.Command current_command = 4;
  inline bool has_current_command() const;
  inline void clear_current_command();
  static const int kCurrentCommandFieldNumber = 4;
  inline const ::mill::Command& current_command() const;
  inline ::mill::Command* mutable_current_command();
  inline ::mill::Command* release_current_command();
  
  // @@protoc_insertion_point(class_scope:mill.MillState)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();
  inline void set_has_current_command();
  inline void clear_has_current_command();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::mill::MillState_Axis* x_;
  ::mill::MillState_Axis* y_;
  ::mill::MillState_Axis* z_;
  ::mill::Command* current_command_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_mill_2eproto();
  friend void protobuf_AssignDesc_mill_2eproto();
  friend void protobuf_ShutdownFile_mill_2eproto();
  
  void InitAsDefaultInstance();
  static MillState* default_instance_;
};
// -------------------------------------------------------------------

class Request : public ::google::protobuf::Message {
 public:
  Request();
  virtual ~Request();
  
  Request(const Request& from);
  
  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();
  
  void Swap(Request* other);
  
  // implements Message ----------------------------------------------
  
  Request* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .mill.Command command = 1;
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 1;
  inline const ::mill::Command& command() const;
  inline ::mill::Command* mutable_command();
  inline ::mill::Command* release_command();
  
  // optional .mill.CommandList command_list = 2;
  inline bool has_command_list() const;
  inline void clear_command_list();
  static const int kCommandListFieldNumber = 2;
  inline const ::mill::CommandList& command_list() const;
  inline ::mill::CommandList* mutable_command_list();
  inline ::mill::CommandList* release_command_list();
  
  // @@protoc_insertion_point(class_scope:mill.Request)
 private:
  inline void set_has_command();
  inline void clear_has_command();
  inline void set_has_command_list();
  inline void clear_has_command_list();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::mill::Command* command_;
  ::mill::CommandList* command_list_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_mill_2eproto();
  friend void protobuf_AssignDesc_mill_2eproto();
  friend void protobuf_ShutdownFile_mill_2eproto();
  
  void InitAsDefaultInstance();
  static Request* default_instance_;
};
// -------------------------------------------------------------------

class Response : public ::google::protobuf::Message {
 public:
  Response();
  virtual ~Response();
  
  Response(const Response& from);
  
  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Response& default_instance();
  
  void Swap(Response* other);
  
  // implements Message ----------------------------------------------
  
  Response* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .mill.CommandReceived command_received = 1;
  inline bool has_command_received() const;
  inline void clear_command_received();
  static const int kCommandReceivedFieldNumber = 1;
  inline const ::mill::CommandReceived& command_received() const;
  inline ::mill::CommandReceived* mutable_command_received();
  inline ::mill::CommandReceived* release_command_received();
  
  // optional .mill.CommandComplete command_complete = 2;
  inline bool has_command_complete() const;
  inline void clear_command_complete();
  static const int kCommandCompleteFieldNumber = 2;
  inline const ::mill::CommandComplete& command_complete() const;
  inline ::mill::CommandComplete* mutable_command_complete();
  inline ::mill::CommandComplete* release_command_complete();
  
  // optional .mill.MillState mill_state = 3;
  inline bool has_mill_state() const;
  inline void clear_mill_state();
  static const int kMillStateFieldNumber = 3;
  inline const ::mill::MillState& mill_state() const;
  inline ::mill::MillState* mutable_mill_state();
  inline ::mill::MillState* release_mill_state();
  
  // @@protoc_insertion_point(class_scope:mill.Response)
 private:
  inline void set_has_command_received();
  inline void clear_has_command_received();
  inline void set_has_command_complete();
  inline void clear_has_command_complete();
  inline void set_has_mill_state();
  inline void clear_has_mill_state();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::mill::CommandReceived* command_received_;
  ::mill::CommandComplete* command_complete_;
  ::mill::MillState* mill_state_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_mill_2eproto();
  friend void protobuf_AssignDesc_mill_2eproto();
  friend void protobuf_ShutdownFile_mill_2eproto();
  
  void InitAsDefaultInstance();
  static Response* default_instance_;
};
// ===================================================================


// ===================================================================

// Command

// optional .mill.Command.CommandType type = 1;
inline bool Command::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Command::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Command::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Command::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mill::Command_CommandType Command::type() const {
  return static_cast< ::mill::Command_CommandType >(type_);
}
inline void Command::set_type(::mill::Command_CommandType value) {
  GOOGLE_DCHECK(::mill::Command_CommandType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional double x = 2;
inline bool Command::has_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Command::set_has_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Command::clear_has_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Command::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double Command::x() const {
  return x_;
}
inline void Command::set_x(double value) {
  set_has_x();
  x_ = value;
}

// optional double y = 3;
inline bool Command::has_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Command::set_has_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Command::clear_has_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Command::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double Command::y() const {
  return y_;
}
inline void Command::set_y(double value) {
  set_has_y();
  y_ = value;
}

// optional double z = 4;
inline bool Command::has_z() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Command::set_has_z() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Command::clear_has_z() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Command::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double Command::z() const {
  return z_;
}
inline void Command::set_z(double value) {
  set_has_z();
  z_ = value;
}

// optional double v = 5;
inline bool Command::has_v() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Command::set_has_v() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Command::clear_has_v() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Command::clear_v() {
  v_ = 0;
  clear_has_v();
}
inline double Command::v() const {
  return v_;
}
inline void Command::set_v(double value) {
  set_has_v();
  v_ = value;
}

// optional double a = 6;
inline bool Command::has_a() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Command::set_has_a() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Command::clear_has_a() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Command::clear_a() {
  a_ = 0;
  clear_has_a();
}
inline double Command::a() const {
  return a_;
}
inline void Command::set_a(double value) {
  set_has_a();
  a_ = value;
}

// optional double i = 7;
inline bool Command::has_i() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Command::set_has_i() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Command::clear_has_i() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Command::clear_i() {
  i_ = 0;
  clear_has_i();
}
inline double Command::i() const {
  return i_;
}
inline void Command::set_i(double value) {
  set_has_i();
  i_ = value;
}

// optional double j = 8;
inline bool Command::has_j() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Command::set_has_j() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Command::clear_has_j() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Command::clear_j() {
  j_ = 0;
  clear_has_j();
}
inline double Command::j() const {
  return j_;
}
inline void Command::set_j(double value) {
  set_has_j();
  j_ = value;
}

// optional double k = 9;
inline bool Command::has_k() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Command::set_has_k() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Command::clear_has_k() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Command::clear_k() {
  k_ = 0;
  clear_has_k();
}
inline double Command::k() const {
  return k_;
}
inline void Command::set_k(double value) {
  set_has_k();
  k_ = value;
}

// -------------------------------------------------------------------

// CommandList

// repeated .mill.Command command = 1;
inline int CommandList::command_size() const {
  return command_.size();
}
inline void CommandList::clear_command() {
  command_.Clear();
}
inline const ::mill::Command& CommandList::command(int index) const {
  return command_.Get(index);
}
inline ::mill::Command* CommandList::mutable_command(int index) {
  return command_.Mutable(index);
}
inline ::mill::Command* CommandList::add_command() {
  return command_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mill::Command >&
CommandList::command() const {
  return command_;
}
inline ::google::protobuf::RepeatedPtrField< ::mill::Command >*
CommandList::mutable_command() {
  return &command_;
}

// -------------------------------------------------------------------

// CommandReceived

// optional int32 number = 1;
inline bool CommandReceived::has_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandReceived::set_has_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandReceived::clear_has_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandReceived::clear_number() {
  number_ = 0;
  clear_has_number();
}
inline ::google::protobuf::int32 CommandReceived::number() const {
  return number_;
}
inline void CommandReceived::set_number(::google::protobuf::int32 value) {
  set_has_number();
  number_ = value;
}

// -------------------------------------------------------------------

// CommandComplete

// optional int32 number = 1;
inline bool CommandComplete::has_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandComplete::set_has_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandComplete::clear_has_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandComplete::clear_number() {
  number_ = 0;
  clear_has_number();
}
inline ::google::protobuf::int32 CommandComplete::number() const {
  return number_;
}
inline void CommandComplete::set_number(::google::protobuf::int32 value) {
  set_has_number();
  number_ = value;
}

// -------------------------------------------------------------------

// MillState_Axis

// optional .mill.MillState.Axis.Direction direction = 1;
inline bool MillState_Axis::has_direction() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MillState_Axis::set_has_direction() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MillState_Axis::clear_has_direction() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MillState_Axis::clear_direction() {
  direction_ = 0;
  clear_has_direction();
}
inline ::mill::MillState_Axis_Direction MillState_Axis::direction() const {
  return static_cast< ::mill::MillState_Axis_Direction >(direction_);
}
inline void MillState_Axis::set_direction(::mill::MillState_Axis_Direction value) {
  GOOGLE_DCHECK(::mill::MillState_Axis_Direction_IsValid(value));
  set_has_direction();
  direction_ = value;
}

// optional double position = 2;
inline bool MillState_Axis::has_position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MillState_Axis::set_has_position() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MillState_Axis::clear_has_position() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MillState_Axis::clear_position() {
  position_ = 0;
  clear_has_position();
}
inline double MillState_Axis::position() const {
  return position_;
}
inline void MillState_Axis::set_position(double value) {
  set_has_position();
  position_ = value;
}

// optional double velocity = 3;
inline bool MillState_Axis::has_velocity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MillState_Axis::set_has_velocity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MillState_Axis::clear_has_velocity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MillState_Axis::clear_velocity() {
  velocity_ = 0;
  clear_has_velocity();
}
inline double MillState_Axis::velocity() const {
  return velocity_;
}
inline void MillState_Axis::set_velocity(double value) {
  set_has_velocity();
  velocity_ = value;
}

// optional double acceleration = 4;
inline bool MillState_Axis::has_acceleration() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MillState_Axis::set_has_acceleration() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MillState_Axis::clear_has_acceleration() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MillState_Axis::clear_acceleration() {
  acceleration_ = 0;
  clear_has_acceleration();
}
inline double MillState_Axis::acceleration() const {
  return acceleration_;
}
inline void MillState_Axis::set_acceleration(double value) {
  set_has_acceleration();
  acceleration_ = value;
}

// -------------------------------------------------------------------

// MillState

// optional .mill.MillState.Axis x = 1;
inline bool MillState::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MillState::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MillState::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MillState::clear_x() {
  if (x_ != NULL) x_->::mill::MillState_Axis::Clear();
  clear_has_x();
}
inline const ::mill::MillState_Axis& MillState::x() const {
  return x_ != NULL ? *x_ : *default_instance_->x_;
}
inline ::mill::MillState_Axis* MillState::mutable_x() {
  set_has_x();
  if (x_ == NULL) x_ = new ::mill::MillState_Axis;
  return x_;
}
inline ::mill::MillState_Axis* MillState::release_x() {
  clear_has_x();
  ::mill::MillState_Axis* temp = x_;
  x_ = NULL;
  return temp;
}

// optional .mill.MillState.Axis y = 2;
inline bool MillState::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MillState::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MillState::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MillState::clear_y() {
  if (y_ != NULL) y_->::mill::MillState_Axis::Clear();
  clear_has_y();
}
inline const ::mill::MillState_Axis& MillState::y() const {
  return y_ != NULL ? *y_ : *default_instance_->y_;
}
inline ::mill::MillState_Axis* MillState::mutable_y() {
  set_has_y();
  if (y_ == NULL) y_ = new ::mill::MillState_Axis;
  return y_;
}
inline ::mill::MillState_Axis* MillState::release_y() {
  clear_has_y();
  ::mill::MillState_Axis* temp = y_;
  y_ = NULL;
  return temp;
}

// optional .mill.MillState.Axis z = 3;
inline bool MillState::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MillState::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MillState::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MillState::clear_z() {
  if (z_ != NULL) z_->::mill::MillState_Axis::Clear();
  clear_has_z();
}
inline const ::mill::MillState_Axis& MillState::z() const {
  return z_ != NULL ? *z_ : *default_instance_->z_;
}
inline ::mill::MillState_Axis* MillState::mutable_z() {
  set_has_z();
  if (z_ == NULL) z_ = new ::mill::MillState_Axis;
  return z_;
}
inline ::mill::MillState_Axis* MillState::release_z() {
  clear_has_z();
  ::mill::MillState_Axis* temp = z_;
  z_ = NULL;
  return temp;
}

// optional .mill.Command current_command = 4;
inline bool MillState::has_current_command() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MillState::set_has_current_command() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MillState::clear_has_current_command() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MillState::clear_current_command() {
  if (current_command_ != NULL) current_command_->::mill::Command::Clear();
  clear_has_current_command();
}
inline const ::mill::Command& MillState::current_command() const {
  return current_command_ != NULL ? *current_command_ : *default_instance_->current_command_;
}
inline ::mill::Command* MillState::mutable_current_command() {
  set_has_current_command();
  if (current_command_ == NULL) current_command_ = new ::mill::Command;
  return current_command_;
}
inline ::mill::Command* MillState::release_current_command() {
  clear_has_current_command();
  ::mill::Command* temp = current_command_;
  current_command_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Request

// optional .mill.Command command = 1;
inline bool Request::has_command() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request::set_has_command() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request::clear_has_command() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request::clear_command() {
  if (command_ != NULL) command_->::mill::Command::Clear();
  clear_has_command();
}
inline const ::mill::Command& Request::command() const {
  return command_ != NULL ? *command_ : *default_instance_->command_;
}
inline ::mill::Command* Request::mutable_command() {
  set_has_command();
  if (command_ == NULL) command_ = new ::mill::Command;
  return command_;
}
inline ::mill::Command* Request::release_command() {
  clear_has_command();
  ::mill::Command* temp = command_;
  command_ = NULL;
  return temp;
}

// optional .mill.CommandList command_list = 2;
inline bool Request::has_command_list() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request::set_has_command_list() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request::clear_has_command_list() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request::clear_command_list() {
  if (command_list_ != NULL) command_list_->::mill::CommandList::Clear();
  clear_has_command_list();
}
inline const ::mill::CommandList& Request::command_list() const {
  return command_list_ != NULL ? *command_list_ : *default_instance_->command_list_;
}
inline ::mill::CommandList* Request::mutable_command_list() {
  set_has_command_list();
  if (command_list_ == NULL) command_list_ = new ::mill::CommandList;
  return command_list_;
}
inline ::mill::CommandList* Request::release_command_list() {
  clear_has_command_list();
  ::mill::CommandList* temp = command_list_;
  command_list_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Response

// optional .mill.CommandReceived command_received = 1;
inline bool Response::has_command_received() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response::set_has_command_received() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response::clear_has_command_received() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response::clear_command_received() {
  if (command_received_ != NULL) command_received_->::mill::CommandReceived::Clear();
  clear_has_command_received();
}
inline const ::mill::CommandReceived& Response::command_received() const {
  return command_received_ != NULL ? *command_received_ : *default_instance_->command_received_;
}
inline ::mill::CommandReceived* Response::mutable_command_received() {
  set_has_command_received();
  if (command_received_ == NULL) command_received_ = new ::mill::CommandReceived;
  return command_received_;
}
inline ::mill::CommandReceived* Response::release_command_received() {
  clear_has_command_received();
  ::mill::CommandReceived* temp = command_received_;
  command_received_ = NULL;
  return temp;
}

// optional .mill.CommandComplete command_complete = 2;
inline bool Response::has_command_complete() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response::set_has_command_complete() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response::clear_has_command_complete() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response::clear_command_complete() {
  if (command_complete_ != NULL) command_complete_->::mill::CommandComplete::Clear();
  clear_has_command_complete();
}
inline const ::mill::CommandComplete& Response::command_complete() const {
  return command_complete_ != NULL ? *command_complete_ : *default_instance_->command_complete_;
}
inline ::mill::CommandComplete* Response::mutable_command_complete() {
  set_has_command_complete();
  if (command_complete_ == NULL) command_complete_ = new ::mill::CommandComplete;
  return command_complete_;
}
inline ::mill::CommandComplete* Response::release_command_complete() {
  clear_has_command_complete();
  ::mill::CommandComplete* temp = command_complete_;
  command_complete_ = NULL;
  return temp;
}

// optional .mill.MillState mill_state = 3;
inline bool Response::has_mill_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Response::set_has_mill_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Response::clear_has_mill_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Response::clear_mill_state() {
  if (mill_state_ != NULL) mill_state_->::mill::MillState::Clear();
  clear_has_mill_state();
}
inline const ::mill::MillState& Response::mill_state() const {
  return mill_state_ != NULL ? *mill_state_ : *default_instance_->mill_state_;
}
inline ::mill::MillState* Response::mutable_mill_state() {
  set_has_mill_state();
  if (mill_state_ == NULL) mill_state_ = new ::mill::MillState;
  return mill_state_;
}
inline ::mill::MillState* Response::release_mill_state() {
  clear_has_mill_state();
  ::mill::MillState* temp = mill_state_;
  mill_state_ = NULL;
  return temp;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace mill

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mill::Command_CommandType>() {
  return ::mill::Command_CommandType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mill::MillState_Axis_Direction>() {
  return ::mill::MillState_Axis_Direction_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_mill_2eproto__INCLUDED
